{"version":3,"file":"imports.js","sourceRoot":"","sources":["../../../src/zeladores/util/imports.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\r\n/**\r\n * Helper puro para reescrever imports relativos quando um arquivo é movido.\r\n * Não toca disco; apenas retorna o novo conteúdo.\r\n */\r\nimport path from 'node:path';\r\n\r\nexport interface ImportReescrito {\r\n  from: string;\r\n  to: string;\r\n}\r\n\r\nexport function reescreverImports(\r\n  conteudo: string,\r\n  arquivoDe: string,\r\n  arquivoPara: string,\r\n): { novoConteudo: string; reescritos: ImportReescrito[] } {\r\n  // Suporta import/export from e require simples\r\n  const padrao =\r\n    /(import\\s+[^'\";]+from\\s*['\"]([^'\"\\n]+)['\"]\\s*;?|export\\s+\\*?\\s*from\\s*['\"]([^'\"\\n]+)['\"];?|require\\(\\s*['\"]([^'\"\\n]+)['\"]\\s*\\))/g;\r\n  const norm = (p: string) => path.posix.normalize(p.replace(/\\\\/g, '/'));\r\n  const baseDe = path.posix.dirname(norm(arquivoDe));\r\n  const basePara = path.posix.dirname(norm(arquivoPara));\r\n  // raízes calculadas anteriormente não são usadas; mantemos somente baseDe/basePara\r\n  const reescritos: ImportReescrito[] = [];\r\n\r\n  const novoConteudo = conteudo.replace(padrao, (full, _i1, gFrom, gExport, gReq) => {\r\n    const spec = gFrom || gExport || gReq;\r\n    if (!spec) return full;\r\n    // Só reescreve relativos ou aliases iniciando com '@/...' ou caminhos com '/src/'\r\n    const isAliasSrc = spec.startsWith('@/');\r\n    if (!isAliasSrc && !spec.includes('/src/') && !spec.startsWith('./') && !spec.startsWith('../'))\r\n      return full;\r\n    let alvoAntigo: string;\r\n    if (isAliasSrc || spec.includes('/src/')) {\r\n      // Normaliza alias '@/...' para 'src/...'\r\n      const specNormalized = isAliasSrc ? spec.replace(/^@\\//, 'src/') : spec;\r\n      // extrai sempre o segmento após a primeira ocorrência de 'src/'\r\n      // lida com spec que comece com 'src/...', '/src/...', '@/...' (convertido para 'src/...')\r\n      let afterSrc = specNormalized.replace(/^.*src\\//, '');\r\n      // remove extensão .js caso presente para evitar preservá-la nos relativos\r\n      afterSrc = afterSrc.replace(/\\.js$/, '');\r\n      alvoAntigo = norm(path.posix.join('src', afterSrc || ''));\r\n\r\n      // Corrige casos onde testes referenciam caminhos improváveis como src/cli/utils/*\r\n      // Padroniza para src/utils/*, evitando inflar profundidade relativa\r\n      alvoAntigo = alvoAntigo\r\n        .replace(/^src\\/cli\\/utils\\//, 'src/utils/')\r\n        .replace(/^src\\/cli\\//, 'src/')\r\n        // Colapsa o primeiro segmento após src quando for util|utils\r\n        .replace(/^src\\/[^/]+\\/(?:util|utils)\\//, 'src/utils/');\r\n      // Evita duplicação utils/utils\r\n      alvoAntigo = alvoAntigo.replace(/\\/utils\\/utils\\//g, '/utils/');\r\n    } else {\r\n      alvoAntigo = norm(path.posix.join(baseDe, spec));\r\n    }\r\n    let novoRel = path.posix.relative(basePara, alvoAntigo);\r\n    // Normaliza separadores e remove duplicações\r\n    novoRel = path.posix.normalize(novoRel);\r\n    // Remove extensão .js se ainda existir\r\n    novoRel = novoRel.replace(/\\.js$/, '');\r\n    // Garante relativo com ./ ou ../\r\n    if (!novoRel.startsWith('.')) novoRel = './' + novoRel;\r\n    reescritos.push({ from: spec, to: novoRel });\r\n    return full.replace(spec, novoRel);\r\n  });\r\n\r\n  return { novoConteudo, reescritos };\r\n}\r\n"]}