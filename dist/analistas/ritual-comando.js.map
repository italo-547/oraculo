{"version":3,"file":"ritual-comando.js","sourceRoot":"","sources":["../../src/analistas/ritual-comando.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\r\nimport { traverse } from '../nucleo/constelacao/traverse.js';\r\nimport * as t from '@babel/types';\r\nimport type { NodePath } from '@babel/traverse';\r\nimport type { ContextoExecucao, Ocorrencia, TecnicaAplicarResultado } from '../tipos/tipos.js';\r\nimport type { Node } from '@babel/types';\r\n\r\n/**\r\n * Extrai informações do handler de comando, se for função válida.\r\n */\r\nexport interface HandlerInfo {\r\n  func: Node;\r\n  bodyBlock: t.BlockStatement;\r\n  isAnonymous: boolean;\r\n  params: t.Identifier[];\r\n  totalParams: number;\r\n}\r\n\r\nexport function extractHandlerInfo(node: unknown): HandlerInfo | null {\r\n  if (!node || typeof node !== 'object') return null;\r\n  // Usa any temporário para permitir checagens estruturais antes de delegar ao tipo de @babel/types\r\n  // O tipo exato depende do nó, mas para evitar any, pode-se usar Node do @babel/types\r\n  const n = node as import('@babel/types').Node;\r\n  if (t.isFunctionDeclaration(n) && n.body && t.isBlockStatement(n.body)) {\r\n    const rawParams = Array.isArray(n.params) ? n.params : [];\r\n    const params: t.Identifier[] = rawParams.filter((p): p is t.Identifier => t.isIdentifier(p));\r\n    return {\r\n      func: n,\r\n      bodyBlock: n.body,\r\n      isAnonymous: !n.id,\r\n      params,\r\n      totalParams: rawParams.length,\r\n    };\r\n  }\r\n  if (\r\n    (t.isFunctionExpression(n) || t.isArrowFunctionExpression(n)) &&\r\n    n.body &&\r\n    t.isBlockStatement(n.body)\r\n  ) {\r\n    const rawParams = Array.isArray(n.params) ? n.params : [];\r\n    const params: t.Identifier[] = rawParams.filter((p): p is t.Identifier => t.isIdentifier(p));\r\n    const isAnonymous = t.isFunctionExpression(n) ? !n.id : true;\r\n    return { func: n, bodyBlock: n.body, isAnonymous, params, totalParams: rawParams.length };\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * Analisa comandos registrados (onCommand/registerCommand), detecta duplicidade, handlers inválidos, boas práticas.\r\n * Retorna ocorrências para cada problema ou padrão detectado.\r\n */\r\nexport const ritualComando = {\r\n  nome: 'ritual-comando',\r\n  test: (relPath: string): boolean => {\r\n    // Delega escopo ao scanner/CLI. Aqui só filtramos por extensão e ignoramos testes/specs\r\n    const p = relPath.replace(/\\\\/g, '/').toLowerCase();\r\n    if (/(^|\\/)tests?(\\/)/i.test(p) || /\\.(test|spec)\\.(ts|js|tsx|jsx)$/i.test(p)) return false;\r\n    return /(\\.ts|\\.tsx|\\.js|\\.jsx)$/.test(p);\r\n  },\r\n\r\n  aplicar(\r\n    conteudo: string,\r\n    arquivo: string,\r\n    ast: NodePath | null,\r\n    _fullPath?: string,\r\n    _contexto?: ContextoExecucao,\r\n  ): TecnicaAplicarResultado {\r\n    const ocorrencias: Ocorrencia[] = [];\r\n    interface ComandoRegistro {\r\n      comandoNome: string; // nome lógico do comando\r\n      handler: Node | undefined;\r\n      info: HandlerInfo | null;\r\n      node: t.CallExpression;\r\n    }\r\n    const comandos: ComandoRegistro[] = [];\r\n    const comandoNomes: string[] = [];\r\n    let comandosInvocados = 0;\r\n\r\n    if (!ast) {\r\n      // Fora de src/ ou quando parser não aplicável, não considerar erro – apenas ignorar\r\n      return [];\r\n    }\r\n\r\n    traverse(ast.node, {\r\n      enter(path: NodePath<t.Node>) {\r\n        const nodeAtual = path.node;\r\n        if (t.isCallExpression(nodeAtual) && t.isIdentifier(nodeAtual.callee)) {\r\n          if (['onCommand', 'registerCommand'].includes(nodeAtual.callee.name)) {\r\n            comandosInvocados++;\r\n            let comandoNome = '';\r\n            const primeiroArg = nodeAtual.arguments[0];\r\n            if (primeiroArg && t.isStringLiteral(primeiroArg)) {\r\n              comandoNome = primeiroArg.value;\r\n              comandoNomes.push(comandoNome);\r\n            }\r\n            const handler = nodeAtual.arguments.length > 1 ? nodeAtual.arguments[1] : undefined;\r\n            // Tentamos extrair informações mesmo em mocks parciais; extractHandlerInfo é defensiva\r\n            const info = extractHandlerInfo(handler as unknown as Node);\r\n            comandos.push({\r\n              comandoNome,\r\n              handler: handler as Node | undefined,\r\n              info,\r\n              node: nodeAtual,\r\n            });\r\n          }\r\n        }\r\n      },\r\n    });\r\n\r\n    if (comandosInvocados === 0) {\r\n      // Só reporta ausência quando o arquivo sugere ser de comandos *e* contém\r\n      // sinais de um módulo CLI (import/require de 'commander', uso de `new Command`,\r\n      // `program.parse`, identificador `program`, etc.). Evita falsos positivos.\r\n      const p = arquivo.replace(/\\\\/g, '/').toLowerCase();\r\n      const looksLikeCliPath = /(^|\\/)(cli|commands?|comandos?|bot)(\\/|\\.|-)/.test(p);\r\n      if (ast && looksLikeCliPath) {\r\n        traverse(ast.node, {\r\n          enter(path: NodePath<t.Node>) {\r\n            const node = path.node as unknown as Record<string, unknown>;\r\n            // Use node.type defensive checks instead of @babel/types helpers to be\r\n            // resilient against partial mocks in test environment.\r\n            const type =\r\n              typeof node === 'object' && node && typeof node.type === 'string' ? node.type : '';\r\n            // import 'commander' or import ... from 'commander'\r\n            if (type === 'ImportDeclaration') {\r\n              const src = (node.source as { value?: unknown })?.value;\r\n              if (typeof src === 'string' && /commander/.test(src)) {\r\n                path.stop();\r\n                return;\r\n              }\r\n            }\r\n            // require('commander') style: CallExpression with callee Identifier 'require'\r\n            if (type === 'CallExpression') {\r\n              const callee = node.callee as Record<string, unknown> | undefined;\r\n              if (\r\n                callee &&\r\n                typeof callee === 'object' &&\r\n                typeof (callee['type'] as unknown) === 'string' &&\r\n                (callee['type'] as string) === 'Identifier' &&\r\n                typeof (callee['name'] as unknown) === 'string' &&\r\n                (callee['name'] as string) === 'require'\r\n              ) {\r\n                const rawArgs = (node as Record<string, unknown>)['arguments'];\r\n                const args = Array.isArray(rawArgs) ? (rawArgs as unknown[]) : [];\r\n                const first = args[0] as Record<string, unknown> | undefined;\r\n                if (\r\n                  first &&\r\n                  typeof (first['type'] as unknown) === 'string' &&\r\n                  (first['type'] as string) === 'StringLiteral' &&\r\n                  typeof (first['value'] as unknown) === 'string'\r\n                ) {\r\n                  if (/commander/.test(first['value'] as string)) {\r\n                    path.stop();\r\n                    return;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            // new Command(...)\r\n            if (type === 'NewExpression') {\r\n              const callee = node.callee as Record<string, unknown> | undefined;\r\n              if (\r\n                callee &&\r\n                typeof callee === 'object' &&\r\n                typeof (callee['type'] as unknown) === 'string' &&\r\n                (callee['type'] as string) === 'Identifier' &&\r\n                typeof (callee['name'] as unknown) === 'string' &&\r\n                (callee['name'] as string) === 'Command'\r\n              ) {\r\n                path.stop();\r\n                return;\r\n              }\r\n            }\r\n            // program.parse(...) or identifier 'program'\r\n            if (type === 'MemberExpression') {\r\n              const obj = node.object as Record<string, unknown> | undefined;\r\n              if (\r\n                obj &&\r\n                typeof obj === 'object' &&\r\n                typeof (obj['type'] as unknown) === 'string' &&\r\n                (obj['type'] as string) === 'Identifier' &&\r\n                typeof (obj['name'] as unknown) === 'string' &&\r\n                (obj['name'] as string) === 'program'\r\n              ) {\r\n                path.stop();\r\n                return;\r\n              }\r\n            }\r\n            if (\r\n              type === 'Identifier' &&\r\n              typeof (node['name'] as unknown) === 'string' &&\r\n              (node['name'] as string) === 'program'\r\n            ) {\r\n              path.stop();\r\n              return;\r\n            }\r\n          },\r\n        });\r\n      }\r\n      if (looksLikeCliPath) {\r\n        // Se o caminho sugere CLI, reporta ausência de comandos. Isso evita\r\n        // falsos negativos: mesmo sem imports explícitos, um arquivo chamado\r\n        // \"bot.js\" ou em pasta \"cli/\" é esperado conter registros de comandos.\r\n        ocorrencias.push({\r\n          tipo: 'padrao-ausente',\r\n          nivel: 'aviso',\r\n          mensagem: 'Nenhum comando registrado usando \"onCommand\" ou \"registerCommand\".',\r\n          relPath: arquivo,\r\n          origem: 'ritual-comando',\r\n        });\r\n      }\r\n    }\r\n\r\n    // Detectar comandos duplicados\r\n    const duplicados = comandoNomes.filter(\r\n      (item, idx) => item && comandoNomes.indexOf(item) !== idx,\r\n    );\r\n    if (duplicados.length > 0) {\r\n      ocorrencias.push({\r\n        tipo: 'padrao-problematico',\r\n        nivel: 'aviso',\r\n        mensagem: `Comandos duplicados detectados: ${[...new Set(duplicados)].join(', ')}`,\r\n        relPath: arquivo,\r\n        origem: 'ritual-comando',\r\n      });\r\n    }\r\n\r\n    // Analisar cada handler\r\n    for (const { comandoNome, handler, info, node } of comandos) {\r\n      let linha = 1;\r\n      if (\r\n        handler &&\r\n        typeof handler === 'object' &&\r\n        handler !== null &&\r\n        'loc' in handler &&\r\n        handler.loc &&\r\n        typeof handler.loc === 'object' &&\r\n        'start' in handler.loc &&\r\n        handler.loc.start &&\r\n        typeof handler.loc.start === 'object' &&\r\n        'line' in (handler.loc.start as unknown as Record<string, unknown>) &&\r\n        typeof (handler.loc.start as unknown as Record<string, unknown>).line === 'number'\r\n      ) {\r\n        linha = (handler.loc.start as unknown as { line: number }).line;\r\n      } else if (node.loc?.start.line) {\r\n        linha = node.loc.start.line;\r\n      }\r\n      if (!info || !info.bodyBlock) {\r\n        // Não é função válida\r\n        continue;\r\n      }\r\n      // Aceita bloco mesmo se body estiver indefinido (considera vazio)\r\n      const statements = Array.isArray(info.bodyBlock.body) ? info.bodyBlock.body : [];\r\n      // Handler anônimo (só reporta se o comando tiver nome explícito)\r\n      if (info.isAnonymous && comandoNome) {\r\n        ocorrencias.push({\r\n          tipo: 'padrao-problematico',\r\n          nivel: 'aviso',\r\n          mensagem: `Handler do comando \"${comandoNome}\" é função anônima. Prefira funções nomeadas para facilitar debugging e rastreabilidade.`,\r\n          relPath: arquivo,\r\n          linha,\r\n          origem: 'ritual-comando',\r\n        });\r\n      }\r\n      // Muitos parâmetros\r\n      // Deriva quantidade de parâmetros sem recorrer a any\r\n      // totalParams já é computado em extractHandlerInfo; fallback para length de params\r\n      const paramCount = info.totalParams ?? info.params.length;\r\n      if (paramCount > 3) {\r\n        ocorrencias.push({\r\n          tipo: 'padrao-problematico',\r\n          nivel: 'aviso',\r\n          mensagem: `Handler do comando${comandoNome ? ` \"${comandoNome}\"` : ''} possui muitos parâmetros (${paramCount}). Avalie simplificar a interface.`,\r\n          relPath: arquivo,\r\n          linha,\r\n          origem: 'ritual-comando',\r\n        });\r\n      }\r\n      // Handler muito longo\r\n      if (statements.length > 30) {\r\n        ocorrencias.push({\r\n          tipo: 'padrao-problematico',\r\n          nivel: 'aviso',\r\n          mensagem: `Handler do comando${comandoNome ? ` \"${comandoNome}\"` : ''} é muito longo (${statements.length} statements). Considere extrair funções auxiliares.`,\r\n          relPath: arquivo,\r\n          linha,\r\n          origem: 'ritual-comando',\r\n        });\r\n      }\r\n      if (statements.length > 0) {\r\n        // Ausência de try/catch\r\n        const hasTryCatch = statements.some((stmt) => t.isTryStatement(stmt));\r\n        if (!hasTryCatch) {\r\n          ocorrencias.push({\r\n            tipo: 'boa-pratica-ausente',\r\n            nivel: 'aviso',\r\n            mensagem: `Handler do comando${comandoNome ? ` \"${comandoNome}\"` : ''} não possui bloco try/catch. Recomenda-se tratar erros explicitamente.`,\r\n            relPath: arquivo,\r\n            linha,\r\n            origem: 'ritual-comando',\r\n          });\r\n        }\r\n        // Ausência de logging ou resposta ao usuário\r\n        // Extrai trecho do conteúdo associado ao body (fallback: conteúdo inteiro se não houver offsets)\r\n        const bodySlice =\r\n          typeof info.bodyBlock.start === 'number' && typeof info.bodyBlock.end === 'number'\r\n            ? conteudo.substring(info.bodyBlock.start, info.bodyBlock.end)\r\n            : '';\r\n        // Fallback para conteúdo completo se slice vazio ou muito curto (pode ter offsets artificiais em mocks de teste)\r\n        const bodySrc = bodySlice && bodySlice.length > 5 ? bodySlice : conteudo;\r\n        const regexLog = /console\\.(log|warn|error)|logger\\.|ctx\\.(reply|send|res|response)/;\r\n        if (!regexLog.test(bodySrc)) {\r\n          // Fallback: se no conteúdo completo existir logging, não reporta\r\n          if (!regexLog.test(conteudo)) {\r\n            ocorrencias.push({\r\n              tipo: 'boa-pratica-ausente',\r\n              nivel: 'aviso',\r\n              mensagem: `Handler do comando${comandoNome ? ` \"${comandoNome}\"` : ''} não faz log nem responde ao usuário. Considere adicionar feedback/logging.`,\r\n              relPath: arquivo,\r\n              linha,\r\n              origem: 'ritual-comando',\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Múltiplos comandos no mesmo arquivo\r\n    if (comandos.length > 1) {\r\n      ocorrencias.push({\r\n        tipo: 'padrao-estrutural',\r\n        nivel: 'info',\r\n        mensagem: `Múltiplos comandos registrados neste arquivo (${comandos.length}). Avalie separar cada comando em seu próprio módulo para melhor manutenção.`,\r\n        relPath: arquivo,\r\n        origem: 'ritual-comando',\r\n      });\r\n    }\r\n\r\n    // Debug temporário (pode ser removido depois) para entender ocorrências inesperadas em testes\r\n    // Logs de debug removidos após estabilização dos testes.\r\n    return Array.isArray(ocorrencias) ? ocorrencias : [];\r\n  },\r\n};\r\n"]}