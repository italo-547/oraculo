{"version":3,"file":"analista-todo-comments.js","sourceRoot":"","sources":["../../src/analistas/analista-todo-comments.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\r\nimport type { Analista, TecnicaAplicarResultado } from '@tipos/tipos.js';\r\nimport { criarOcorrencia } from '@tipos/tipos.js';\r\nimport type { NodePath } from '@babel/traverse';\r\nimport type { Comment } from '@babel/types';\r\n\r\n// Analista simples para detectar TODO em comentários (//, /* */), ignorando testes/specs\r\nexport const analistaTodoComments: Analista = {\r\n  nome: 'todo-comments',\r\n  categoria: 'qualidade',\r\n  descricao: 'Detecta comentários TODO deixados no código (apenas em comentários).',\r\n  test(relPath) {\r\n    // Ignora arquivos de teste/spec e pastas comuns de teste\r\n    if (\r\n      /(^|\\\\|\\/)tests?(\\\\|\\/)/i.test(relPath) ||\r\n      /\\.(test|spec)\\.(ts|js|tsx|jsx)$/i.test(relPath)\r\n    ) {\r\n      return false;\r\n    }\r\n    // Delega escopo ao scanner/CLI: não restringe por caminho aqui\r\n    // normalização não é necessária aqui; scanner controla escopo\r\n    // Evita auto-detecção neste próprio arquivo\r\n    if (/analistas[\\\\\\/]analista-todo-comments\\.(ts|js)$/i.test(relPath)) return false;\r\n    return /\\.(ts|js|tsx|jsx)$/i.test(relPath);\r\n  },\r\n  aplicar(src, relPath, ast?: NodePath | null): TecnicaAplicarResultado {\r\n    if (!src || typeof src !== 'string') return null;\r\n    // Evita auto-detecção neste próprio arquivo (defesa dupla)\r\n    if (/analistas[\\\\\\/]analista-todo-comments\\.(ts|js)$/i.test(relPath)) return null;\r\n\r\n    // Caminho preferencial: usar comentários da AST quando disponível\r\n    if (ast && ast.node) {\r\n      const maybeWithComments = ast.node as unknown as { comments?: Comment[] };\r\n      if (Array.isArray(maybeWithComments.comments)) {\r\n        const comments = maybeWithComments.comments;\r\n        const ocorrencias = comments\r\n          .filter((c) => {\r\n            const texto = String(c.value ?? '').trim();\r\n            return /^TODO\\b/i.test(texto) || /\\bTODO\\b\\s*[:\\-(\\[]/i.test(texto);\r\n          })\r\n          .map((c) =>\r\n            criarOcorrencia({\r\n              tipo: 'TODO_PENDENTE',\r\n              mensagem: 'Comentário TODO encontrado',\r\n              nivel: 'aviso',\r\n              relPath,\r\n              linha: c.loc?.start.line,\r\n              origem: 'todo-comments',\r\n            }),\r\n          );\r\n        return ocorrencias.length ? ocorrencias : null;\r\n      }\r\n    }\r\n\r\n    // Heurística: considera TODO apenas quando presente em comentários\r\n    const linhas = src.split(/\\r?\\n/);\r\n    const ocorrenciasLinhas: number[] = [];\r\n    let emBloco = false;\r\n    const isTodoComment = (texto: string): boolean => {\r\n      const t = texto.trim();\r\n      if (/^TODO\\b/i.test(t)) return true; // começa com TODO (ex: \"// TODO ajustar\")\r\n      return /\\bTODO\\b\\s*[:\\-(\\[]/i.test(t); // TODO: ou TODO - ou TODO(\r\n    };\r\n    for (let i = 0; i < linhas.length; i++) {\r\n      const linha = linhas[i];\r\n      let analisada = false;\r\n\r\n      // Verifica comentários de bloco (/* ... */)\r\n      if (emBloco) {\r\n        analisada = true;\r\n        if (isTodoComment(linha)) {\r\n          ocorrenciasLinhas.push(i + 1);\r\n        }\r\n        if (linha.includes('*/')) {\r\n          emBloco = false;\r\n        }\r\n      }\r\n\r\n      if (!analisada) {\r\n        // Procura início de bloco e comentário de linha\r\n        const idxBlockStart = linha.indexOf('/*');\r\n        const idxLine = linha.indexOf('//');\r\n\r\n        // Caso comentário de linha\r\n        if (idxLine >= 0 && (idxBlockStart === -1 || idxLine < idxBlockStart)) {\r\n          const trechoComentario = linha.slice(idxLine + 2);\r\n          if (isTodoComment(trechoComentario)) {\r\n            ocorrenciasLinhas.push(i + 1);\r\n          }\r\n          continue;\r\n        }\r\n\r\n        // Caso bloco começando nesta linha\r\n        if (idxBlockStart >= 0) {\r\n          const trechoAposInicio = linha.slice(idxBlockStart + 2);\r\n          if (isTodoComment(trechoAposInicio)) {\r\n            ocorrenciasLinhas.push(i + 1);\r\n          }\r\n          if (!linha.includes('*/')) {\r\n            emBloco = true;\r\n          }\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (ocorrenciasLinhas.length === 0) return null;\r\n\r\n    return ocorrenciasLinhas.map((linha) =>\r\n      criarOcorrencia({\r\n        tipo: 'TODO_PENDENTE',\r\n        mensagem: 'Comentário TODO encontrado',\r\n        nivel: 'aviso',\r\n        relPath,\r\n        linha,\r\n        origem: 'todo-comments',\r\n      }),\r\n    );\r\n  },\r\n};\r\n\r\nexport default analistaTodoComments;\r\n"]}