{"version":3,"file":"estrategista-estrutura.js","sourceRoot":"","sources":["../../src/arquitetos/estrategista-estrutura.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\r\nimport path from 'node:path';\r\nimport type { PlanoSugestaoEstrutura, PlanoMoverItem } from '@tipos/plano-estrutura.js';\r\nimport type { ContextoExecucao } from '@tipos/tipos.js';\r\nimport {\r\n  carregarConfigEstrategia,\r\n  destinoPara,\r\n  deveIgnorar,\r\n  normalizarRel,\r\n  OpcoesEstrategista,\r\n} from '@zeladores/util/estrutura.js';\r\n\r\n/**\r\n * Estrategista/Planejador de Estrutura\r\n *\r\n * Responsável por: dado o conjunto de arquivos e um catálogo de arquétipos,\r\n * sugerir um plano de reorganização (mover arquivos) com base em regras de nomeação\r\n * e diretórios-alvo padronizados. Não aplica mudanças no disco (apenas sugere).\r\n *\r\n * Domínio ideal: arquitetos (diagnóstico/planejamento). A execução fica com zeladores.\r\n */\r\n\r\nexport async function gerarPlanoEstrategico(\r\n  contexto: Pick<ContextoExecucao, 'arquivos' | 'baseDir'>,\r\n  opcoes: OpcoesEstrategista = {},\r\n): Promise<PlanoSugestaoEstrutura> {\r\n  const cfg = await carregarConfigEstrategia(contexto.baseDir, opcoes);\r\n  const mover: PlanoMoverItem[] = [];\r\n  const conflitos: { alvo: string; motivo: string }[] = [];\r\n\r\n  // Estratégia atual: heurística de nomeação + config/preset (sem consultar arquétipos aqui para evitar ciclos)\r\n\r\n  const rels = contexto.arquivos.map((f) => normalizarRel(f.relPath));\r\n\r\n  for (const rel of rels) {\r\n    if (deveIgnorar(rel, cfg.ignorarPastas)) continue;\r\n    // Evitar mexer em arquivos fora do escopo de código (por agora)\r\n    if (!rel.endsWith('.ts') && !rel.endsWith('.js')) continue;\r\n\r\n    // Respeita convenções de ferramentas no root: não mover configs globais\r\n    const base = path.posix.basename(rel);\r\n    if (/^(eslint|vitest)\\.config\\.[jt]s$/i.test(base)) continue;\r\n\r\n    const res = destinoPara(rel, cfg.raizCodigo, cfg.criarSubpastasPorEntidade, cfg.categoriasMapa);\r\n    if (!res.destinoDir) continue;\r\n\r\n    // Mantém o mesmo nome do arquivo; apenas move para pasta de destino\r\n    const destino = path.posix.join(res.destinoDir, path.posix.basename(rel));\r\n    // Conflito se já existe arquivo listado ou presente no filesystem\r\n    let destinoExiste = rels.includes(destino);\r\n    if (!destinoExiste) {\r\n      try {\r\n        const abs = path.join(contexto.baseDir, destino.replace(/\\\\/g, '/'));\r\n        // fs.statSync usado de forma segura; se falhar, considera inexistente\r\n        require('node:fs').statSync(abs);\r\n        destinoExiste = true;\r\n      } catch {\r\n        destinoExiste = false;\r\n      }\r\n    }\r\n    if (destinoExiste) {\r\n      conflitos.push({ alvo: destino, motivo: 'destino já existe' });\r\n      continue;\r\n    }\r\n    mover.push({ de: rel, para: destino, motivo: res.motivo });\r\n  }\r\n\r\n  // Deduplicação simples\r\n  const seen = new Set<string>();\r\n  const moverFiltrado = mover.filter((m) => {\r\n    const k = `${m.de}→${m.para}`;\r\n    if (seen.has(k)) return false;\r\n    seen.add(k);\r\n    return true;\r\n  });\r\n\r\n  return {\r\n    mover: moverFiltrado,\r\n    conflitos,\r\n    resumo: {\r\n      total: moverFiltrado.length + conflitos.length,\r\n      zonaVerde: moverFiltrado.length,\r\n      bloqueados: conflitos.length,\r\n    },\r\n  };\r\n}\r\n\r\nexport const EstrategistaEstrutura = {\r\n  nome: 'estrategista-estrutura',\r\n  gerarPlano: gerarPlanoEstrategico,\r\n};\r\n"]}