{"version":3,"file":"inquisidor.js","sourceRoot":"","sources":["../../src/nucleo/inquisidor.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\r\nimport { promises as fs } from 'node:fs';\r\nimport * as path from 'path';\r\nimport { registroAnalistas } from '../analistas/registry.js';\r\nimport { lerEstado } from '../zeladores/util/persistencia.js';\r\nimport { config } from './constelacao/cosmos.js';\r\nimport { log } from './constelacao/log.js';\r\nimport { executarInquisicao as executarExecucao, registrarUltimasMetricas } from './executor.js';\r\nimport { decifrarSintaxe } from './parser.js';\r\nimport { scanRepository } from './scanner.js';\r\nimport { isMetaPath } from './constelacao/paths.js';\r\n// Fallback de símbolos para cenários de teste onde o mock de log não inclui `simbolos`.\r\ninterface SimbolosLog {\r\n  info: string;\r\n  sucesso: string;\r\n  erro: string;\r\n  aviso: string;\r\n  debug: string;\r\n  fase: string;\r\n  passo: string;\r\n  scan: string;\r\n  guardian: string;\r\n  pasta: string;\r\n}\r\nconst SIMBOLOS_FALLBACK: SimbolosLog = {\r\n  info: 'ℹ️',\r\n  sucesso: '✅',\r\n  erro: '❌',\r\n  aviso: '⚠️',\r\n  debug: '🐞',\r\n  fase: '🔶',\r\n  passo: '▫️',\r\n  scan: '🔍',\r\n  guardian: '🛡️',\r\n  pasta: '📂',\r\n};\r\nconst S: SimbolosLog =\r\n  typeof (log as unknown as { simbolos?: SimbolosLog }).simbolos === 'object'\r\n    ? (log as unknown as { simbolos: SimbolosLog }).simbolos\r\n    : SIMBOLOS_FALLBACK;\r\n// Fallback seguro para infoDestaque quando mocks de teste não expõem o método\r\nconst __infoDestaque = (mensagem: string) => {\r\n  const l = log as unknown as { infoDestaque?: (m: string) => void; info: (m: string) => void };\r\n  if (typeof l.infoDestaque === 'function') return l.infoDestaque(mensagem);\r\n  return l.info(mensagem);\r\n};\r\n\r\nimport type {\r\n  FileEntry,\r\n  FileEntryWithAst,\r\n  InquisicaoOptions,\r\n  ResultadoInquisicaoCompleto,\r\n  Tecnica,\r\n} from '../tipos/tipos.js';\r\nimport { ocorrenciaParseErro, OcorrenciaParseErro } from '../tipos/tipos.js';\r\n\r\n// Extensões consideradas para tentativa de AST. Observações:\r\n// - .d.ts é propositalmente excluída pelo parser (retorna null) e aqui não entra.\r\n// - .map (source maps) não deve ser parseado – marcamos como NÃO pertencente ao conjunto.\r\nconst EXTENSOES_COM_AST = new Set(\r\n  Array.isArray(config.SCANNER_EXTENSOES_COM_AST)\r\n    ? config.SCANNER_EXTENSOES_COM_AST\r\n    : ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs'],\r\n);\r\n\r\nexport const tecnicas: Tecnica[] = registroAnalistas as Tecnica[];\r\n\r\nexport async function prepararComAst(\r\n  entries: FileEntry[],\r\n  baseDir: string,\r\n): Promise<FileEntryWithAst[]> {\r\n  // Cache em memória (process-level). Chave: relPath\r\n  // Guarda: { mtimeMs, size, ast }\r\n  type CacheValor = {\r\n    mtimeMs: number;\r\n    size: number;\r\n    ast: import('@babel/traverse').NodePath<import('@babel/types').Node> | undefined;\r\n  };\r\n  interface MetricasGlobais {\r\n    parsingTimeMs: number;\r\n    cacheHits: number;\r\n    cacheMiss: number;\r\n  }\r\n  const globalStore = globalThis as unknown as Record<string, unknown>;\r\n  const cache: Map<string, CacheValor> =\r\n    (globalStore.__ORACULO_AST_CACHE__ as Map<string, CacheValor>) || new Map();\r\n  if (!globalStore.__ORACULO_AST_CACHE__) globalStore.__ORACULO_AST_CACHE__ = cache;\r\n  const metricas: MetricasGlobais = (globalStore.__ORACULO_METRICAS__ as MetricasGlobais) || {\r\n    parsingTimeMs: 0,\r\n    cacheHits: 0,\r\n    cacheMiss: 0,\r\n  };\r\n  // Reset métricas de parsing a cada preparação completa\r\n  metricas.parsingTimeMs = 0;\r\n  metricas.cacheHits = 0;\r\n  metricas.cacheMiss = 0;\r\n  globalStore.__ORACULO_METRICAS__ = metricas;\r\n\r\n  return Promise.all(\r\n    entries.map(async (entry): Promise<FileEntryWithAst> => {\r\n      let ast: import('@babel/traverse').NodePath<import('@babel/types').Node> | undefined =\r\n        undefined;\r\n      const ext = path.extname(entry.relPath);\r\n      const absPath =\r\n        typeof entry.fullPath === 'string' ? entry.fullPath : path.resolve(baseDir, entry.relPath);\r\n      let stats: import('node:fs').Stats | undefined;\r\n      try {\r\n        stats = await fs.stat(absPath);\r\n      } catch {\r\n        stats = undefined;\r\n      }\r\n\r\n      // Detecção de extensão com suporte a sufixos compostos (ex.: .d.ts, .js.map)\r\n      const nomeLower = entry.relPath.toLowerCase();\r\n      const extEfetiva = nomeLower.endsWith('.d.ts')\r\n        ? '.d.ts'\r\n        : nomeLower.endsWith('.map')\r\n          ? '.map'\r\n          : ext;\r\n\r\n      if (entry.content && EXTENSOES_COM_AST.has(extEfetiva)) {\r\n        const chave = entry.relPath;\r\n        if (config.ANALISE_AST_CACHE_ENABLED && stats) {\r\n          const anterior = cache.get(chave);\r\n          if (anterior && anterior.mtimeMs === stats.mtimeMs && anterior.size === stats.size) {\r\n            // Se o cache tinha AST válida, reutiliza; caso contrário, mantém undefined para obrigar tentative parsing novamente.\r\n            ast = anterior.ast;\r\n            metricas.cacheHits++;\r\n          }\r\n        }\r\n        try {\r\n          if (!ast) {\r\n            const inicioParse = performance.now();\r\n            const parsed = await decifrarSintaxe(entry.content, extEfetiva);\r\n            if (parsed && typeof parsed === 'object') {\r\n              // Mantém ast undefined quando parsed é objeto vazio (forma inválida)\r\n              if (Object.keys(parsed as unknown as Record<string, unknown>).length > 0) {\r\n                // Sentinel convertida para o tipo NodePath via unknown cast – suficiente para diferenciar truthy\r\n                ast = {} as unknown as import('@babel/traverse').NodePath<\r\n                  import('@babel/types').Node\r\n                >;\r\n              }\r\n            } else if (parsed == null) {\r\n              // Politica: para arquivos em node_modules, não tratar falha de parsing como erro;\r\n              // em vez disso, seguimos com um sentinel de AST para permitir analistas que não dependem de AST completa.\r\n              const inNodeModules = /(^|\\/)node_modules(\\/|\\\\)/.test(entry.relPath);\r\n              if (inNodeModules) {\r\n                ast = {} as unknown as import('@babel/traverse').NodePath<\r\n                  import('@babel/types').Node\r\n                >;\r\n              } else {\r\n                const globalStore2 = globalStore as unknown as Record<string, unknown>;\r\n                const lista =\r\n                  (globalStore2.__ORACULO_PARSE_ERROS__ as OcorrenciaParseErro[] | undefined) || [];\r\n                lista.push(\r\n                  ocorrenciaParseErro({\r\n                    mensagem: 'Erro de parsing: AST não gerada (código possivelmente inválido).',\r\n                    relPath: entry.relPath,\r\n                    origem: 'parser',\r\n                  }),\r\n                );\r\n                globalStore2.__ORACULO_PARSE_ERROS__ = lista;\r\n              }\r\n            }\r\n            metricas.parsingTimeMs += performance.now() - inicioParse;\r\n            metricas.cacheMiss++;\r\n            if (config.ANALISE_AST_CACHE_ENABLED && stats) {\r\n              cache.set(entry.relPath, { mtimeMs: stats.mtimeMs, size: stats.size, ast });\r\n            }\r\n          }\r\n        } catch (e) {\r\n          const err = e as Error;\r\n          log.erro(`Falha ao gerar AST para ${entry.relPath}: ${err.message}`);\r\n          // Registra ocorrência de parse erro\r\n          const lista =\r\n            (globalStore.__ORACULO_PARSE_ERROS__ as OcorrenciaParseErro[] | undefined) || [];\r\n          lista.push(\r\n            ocorrenciaParseErro({\r\n              mensagem: `Erro de parsing: ${err.message}`,\r\n              relPath: entry.relPath,\r\n              origem: 'parser',\r\n            }),\r\n          );\r\n          globalStore.__ORACULO_PARSE_ERROS__ = lista;\r\n        }\r\n      }\r\n\r\n      return {\r\n        ...entry,\r\n        ast,\r\n        fullPath:\r\n          typeof entry.fullPath === 'string'\r\n            ? entry.fullPath\r\n            : path.resolve(baseDir, entry.relPath),\r\n      };\r\n    }),\r\n  );\r\n}\r\n\r\nexport async function iniciarInquisicao(\r\n  baseDir: string = process.cwd(),\r\n  options: InquisicaoOptions = {},\r\n): Promise<ResultadoInquisicaoCompleto> {\r\n  const { includeContent = true, incluirMetadados = true, skipExec = false } = options;\r\n  log.info(`${S.scan} Iniciando a Inquisição do Oráculo em: ${baseDir}`);\r\n\r\n  const fileMap = await scanRepository(baseDir, {\r\n    includeContent,\r\n    onProgress: (msg) => {\r\n      // Só exibe diretórios e erros, e em formato legível por máquina/pessoa\r\n      try {\r\n        const obj = JSON.parse(msg);\r\n        if (obj.tipo === 'diretorio') {\r\n          // Atualiza contador e amostra em memória, sem emitir logs incrementais.\r\n          // A política semântica correta: não mostrar progresso parcial durante a varredura;\r\n          // em vez disso, exibimos apenas um resumo final após a conclusão da varredura.\r\n          const g = globalThis as unknown as {\r\n            __ORACULO_DIR_COUNT__?: number;\r\n            __ORACULO_DIR_SAMPLES__?: string[];\r\n          };\r\n          g.__ORACULO_DIR_COUNT__ = (g.__ORACULO_DIR_COUNT__ || 0) + 1;\r\n          // Armazena primeiros N diretórios como amostra para diagnóstico posterior\r\n          const SAMPLE_MAX = 5;\r\n          if (!g.__ORACULO_DIR_SAMPLES__) g.__ORACULO_DIR_SAMPLES__ = [];\r\n          if (g.__ORACULO_DIR_SAMPLES__.length < SAMPLE_MAX) {\r\n            g.__ORACULO_DIR_SAMPLES__.push(obj.caminho);\r\n          }\r\n          // contador atualizado em g.__ORACULO_DIR_COUNT__ (não usado diretamente aqui)\r\n          // Em modo verbose original poderíamos mostrar mais detalhes, mas por padrão\r\n          // evitamos ruído progressivo. Erros continuam sendo reportados abaixo.\r\n        } else if (obj.tipo === 'erro') {\r\n          log.erro(`Erro ao ${obj.acao} ${obj.caminho}: ${obj.mensagem}`);\r\n        }\r\n      } catch {\r\n        // fallback para logs antigos\r\n        if (msg && msg.includes('⚠️')) log.aviso(msg);\r\n      }\r\n    },\r\n  });\r\n  let fileEntries: FileEntryWithAst[];\r\n\r\n  let entriesBase = Object.values(fileMap);\r\n  // Filtra arquivos meta com helper central: tudo fora de src/ é meta por padrão\r\n  const metaSet = new Set(entriesBase.filter((e) => isMetaPath(e.relPath)).map((e) => e.relPath));\r\n  // Priorização (usa estado incremental anterior somente para ordenar)\r\n  if (config.ANALISE_PRIORIZACAO_ENABLED && config.ANALISE_INCREMENTAL_STATE_PATH) {\r\n    try {\r\n      interface EstadoIncArquivo {\r\n        hash: string;\r\n        ocorrencias: OcorrenciaParseErro[];\r\n        analistas?: Record<string, { ocorrencias: number; duracaoMs: number }>;\r\n        reaproveitadoCount?: number;\r\n      }\r\n      type EstadoIncremental = { arquivos: Record<string, EstadoIncArquivo> };\r\n      const inc = await lerEstado<EstadoIncremental>(config.ANALISE_INCREMENTAL_STATE_PATH).catch(\r\n        () => null,\r\n      );\r\n      if (inc && inc.arquivos) {\r\n        const pesos = (config.ANALISE_PRIORIZACAO_PESOS || {\r\n          duracaoMs: 1,\r\n          ocorrencias: 2,\r\n          penalidadeReuso: 0.5,\r\n        }) as { duracaoMs: number; ocorrencias: number; penalidadeReuso: number };\r\n        const scored = entriesBase.map((e) => {\r\n          const hist = inc.arquivos[e.relPath];\r\n          if (!hist) return { ...e, __score: 0 } as FileEntry & { __score: number };\r\n          let dur = 0;\r\n          let occ = 0;\r\n          if (hist.analistas) {\r\n            for (const a of Object.values(hist.analistas)) {\r\n              dur += a.duracaoMs;\r\n              occ += a.ocorrencias;\r\n            }\r\n          } else {\r\n            occ = hist.ocorrencias?.length || 0;\r\n          }\r\n          const reuso = hist.reaproveitadoCount || 0;\r\n          const score =\r\n            dur * pesos.duracaoMs + occ * pesos.ocorrencias - reuso * pesos.penalidadeReuso;\r\n          return { ...e, __score: score } as FileEntry & { __score: number };\r\n        });\r\n        scored.sort(\r\n          (a, b) =>\r\n            (b as unknown as { __score: number }).__score -\r\n            (a as unknown as { __score: number }).__score,\r\n        );\r\n        // Reorganiza empurrando meta para o final\r\n        const prioritarios: (FileEntry & { __score: number })[] = [];\r\n        const metas: (FileEntry & { __score: number })[] = [];\r\n        for (const s of scored) (metaSet.has(s.relPath) ? metas : prioritarios).push(s);\r\n        const reconstituido = [...prioritarios, ...metas];\r\n        entriesBase = reconstituido as unknown as typeof entriesBase;\r\n        const somentePrioritarios = reconstituido.filter((e) => !metaSet.has(e.relPath));\r\n        if (config.LOG_ESTRUTURADO) {\r\n          log.info(\r\n            JSON.stringify({\r\n              tipo: 'priorizacao',\r\n              estrategia: 'historico-incremental',\r\n              top: somentePrioritarios.slice(0, 10).map((e) => ({\r\n                arq: e.relPath,\r\n                score: (e as unknown as { __score: number }).__score,\r\n              })),\r\n              metaEmpurrados: metas.length,\r\n            }),\r\n          );\r\n        } else {\r\n          const exibidos =\r\n            somentePrioritarios\r\n              .slice(0, 5)\r\n              .map((e) => e.relPath)\r\n              .join(', ') || '—';\r\n          log.info(`🧮 Priorização aplicada (top 5 sem meta): ${exibidos}`);\r\n          if (metas.length) {\r\n            log.info(`   (${S.info} ${metas.length} arquivos meta movidos para o final da fila)`);\r\n          }\r\n        }\r\n      }\r\n    } catch (e) {\r\n      if (config.DEV_MODE) log.erro(`Falha priorização: ${(e as Error).message}`);\r\n    }\r\n  }\r\n\r\n  if (incluirMetadados) {\r\n    fileEntries = await prepararComAst(entriesBase, baseDir);\r\n  } else {\r\n    fileEntries = entriesBase.map((entry) => ({\r\n      ...entry,\r\n      ast: undefined,\r\n      fullPath:\r\n        typeof entry.fullPath === 'string' ? entry.fullPath : path.resolve(baseDir, entry.relPath),\r\n    }));\r\n  }\r\n\r\n  // Exibe um resumo único da varredura preliminar, imediatamente antes da análise principal.\r\n  try {\r\n    const g = globalThis as unknown as {\r\n      __ORACULO_DIR_COUNT__?: number;\r\n      __ORACULO_DIR_SAMPLES__?: string[];\r\n    };\r\n    const totalDirs = g.__ORACULO_DIR_COUNT__ || 0;\r\n    // Não exibir caminhos nem moldura — apenas resumo simples em texto.\r\n    const amostra = Array.isArray(g.__ORACULO_DIR_SAMPLES__) ? g.__ORACULO_DIR_SAMPLES__ : [];\r\n    if (config.LOG_ESTRUTURADO) {\r\n      log.info(\r\n        JSON.stringify({\r\n          tipo: 'varredura_preliminar',\r\n          totalDiretorios: totalDirs,\r\n          amostraDiretorios: amostra,\r\n        }),\r\n      );\r\n    } else {\r\n      // Saída plain-text solicitada (sem moldura nem caminhos detalhados)\r\n      // Exemplo:\r\n      // resumos varredura preliminar:\r\n      //\r\n      // Diretórios escaneados: ?\r\n      // arquivos escaneados: ?\r\n      // Usamos log.info para que testes possam interceptar a saída\r\n      log.info('resumos varredura preliminar:');\r\n      log.info('');\r\n      log.info(`Diretórios escaneados: ${totalDirs}`);\r\n      log.info(`arquivos escaneados: ${fileEntries.length}`);\r\n    }\r\n  } catch {\r\n    /* ignore */\r\n  }\r\n\r\n  // Agora fileEntries é FileEntryWithAst[]\r\n  let totalArquivos = fileEntries.length;\r\n  let ocorrencias: Array<OcorrenciaParseErro | import('../tipos/tipos.js').Ocorrencia> = [];\r\n  if (!skipExec) {\r\n    const execRes = await executarExecucao(fileEntries, tecnicas, baseDir, undefined);\r\n    totalArquivos = execRes.totalArquivos;\r\n    ocorrencias = execRes.ocorrencias;\r\n  }\r\n\r\n  // Anexa ocorrências de parse se existirem\r\n  const parseErros: OcorrenciaParseErro[] =\r\n    ((globalThis as unknown as Record<string, unknown>)\r\n      .__ORACULO_PARSE_ERROS__ as OcorrenciaParseErro[]) || [];\r\n  if (parseErros.length) {\r\n    // Armazena contagem original para métricas (usado em saída JSON)\r\n    (\r\n      globalThis as unknown as { __ORACULO_PARSE_ERROS_ORIGINAIS__?: number }\r\n    ).__ORACULO_PARSE_ERROS_ORIGINAIS__ = parseErros.length;\r\n    if (config.PARSE_ERRO_AGRUPAR) {\r\n      const porArquivo: Record<string, OcorrenciaParseErro[]> = {};\r\n      for (const pe of parseErros) {\r\n        const k = pe.relPath || '__desconhecido__';\r\n        (porArquivo[k] = porArquivo[k] || []).push(pe);\r\n      }\r\n      for (const [arq, lista] of Object.entries(porArquivo)) {\r\n        if (lista.length <= (config.PARSE_ERRO_MAX_POR_ARQUIVO || 1)) {\r\n          ocorrencias.push(...lista);\r\n        } else {\r\n          // Consolida em uma única ocorrência representativa\r\n          ocorrencias.push(\r\n            ocorrenciaParseErro({\r\n              mensagem: `Erros de parsing agregados: ${lista.length} ocorrências suprimidas neste arquivo (exibe 1).`,\r\n              relPath: arq === '__desconhecido__' ? undefined : arq,\r\n              origem: 'parser',\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      ocorrencias.push(...parseErros);\r\n    }\r\n  }\r\n\r\n  if (!skipExec) {\r\n    log.sucesso(`🔮 Inquisição concluída. Total de ocorrências: ${ocorrencias.length}`);\r\n  } else if (!config.COMPACT_MODE) {\r\n    __infoDestaque(`Varredura concluída: total de arquivos: ${fileEntries.length}`);\r\n  }\r\n\r\n  return {\r\n    totalArquivos,\r\n    ocorrencias,\r\n    arquivosAnalisados: fileEntries.map((f) => f.relPath),\r\n    timestamp: Date.now(),\r\n    duracaoMs: 0,\r\n    fileEntries,\r\n    guardian: undefined,\r\n  };\r\n}\r\n\r\nexport { executarExecucao as executarInquisicao, registrarUltimasMetricas };\r\n"]}