{"version":3,"file":"analista-funcoes-longas.js","sourceRoot":"","sources":["../../src/analistas/analista-funcoes-longas.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\r\n// ...existing code...\r\nimport type { Ocorrencia } from '@tipos/tipos.js';\r\nimport { criarAnalista } from '@tipos/tipos.js';\r\nimport { config } from '@nucleo/constelacao/cosmos.js';\r\nimport type {\r\n  FunctionDeclaration,\r\n  FunctionExpression,\r\n  ArrowFunctionExpression,\r\n} from '@babel/types';\r\nimport type { NodePath } from '@babel/traverse';\r\n\r\nconst LIMITE_LINHAS = config.ANALISE_LIMITES?.FUNCOES_LONGAS?.MAX_LINHAS ?? 30;\r\nconst LIMITE_PARAMETROS = config.ANALISE_LIMITES?.FUNCOES_LONGAS?.MAX_PARAMETROS ?? 4;\r\nconst LIMITE_ANINHAMENTO = config.ANALISE_LIMITES?.FUNCOES_LONGAS?.MAX_ANINHAMENTO ?? 3;\r\n\r\nexport const analistaFuncoesLongas = criarAnalista({\r\n  aplicar: function (src: string, relPath: string, ast: NodePath | null, _fullPath?: string) {\r\n    const ocorrencias: Ocorrencia[] = [];\r\n\r\n    function analisar(\r\n      fn: FunctionDeclaration | FunctionExpression | ArrowFunctionExpression,\r\n      _aninhamento: number = 0,\r\n    ): void {\r\n      if (\r\n        !fn.loc ||\r\n        typeof fn.loc.start !== 'object' ||\r\n        typeof fn.loc.end !== 'object' ||\r\n        typeof fn.loc.start.line !== 'number' ||\r\n        typeof fn.loc.end.line !== 'number' ||\r\n        fn.loc.start.line < 1 ||\r\n        fn.loc.end.line < fn.loc.start.line\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      const startLine = fn.loc.start.line;\r\n      const endLine = fn.loc.end.line;\r\n      const linhas = endLine - startLine + 1;\r\n      if (linhas > LIMITE_LINHAS) {\r\n        ocorrencias.push({\r\n          tipo: 'FUNCAO_LONGA',\r\n          severidade: 2,\r\n          nivel: 'aviso',\r\n          relPath,\r\n          arquivo: relPath,\r\n          linha: startLine,\r\n          mensagem: `Função com ${linhas} linhas (máx: ${LIMITE_LINHAS})`,\r\n          origem: 'analista-funcoes-longas',\r\n        });\r\n      }\r\n\r\n      if (fn.params && Array.isArray(fn.params) && fn.params.length > LIMITE_PARAMETROS) {\r\n        ocorrencias.push({\r\n          tipo: 'MUITOS_PARAMETROS',\r\n          severidade: 1,\r\n          nivel: 'aviso',\r\n          relPath,\r\n          arquivo: relPath,\r\n          linha: startLine,\r\n          mensagem: `Função com muitos parâmetros (${fn.params.length}, máx: ${LIMITE_PARAMETROS})`,\r\n          origem: 'analista-funcoes-longas',\r\n        });\r\n      }\r\n\r\n      // Verifica se a função está aninhada demais\r\n      if (_aninhamento > LIMITE_ANINHAMENTO) {\r\n        ocorrencias.push({\r\n          tipo: 'FUNCAO_ANINHADA',\r\n          severidade: 1,\r\n          nivel: 'aviso',\r\n          relPath,\r\n          arquivo: relPath,\r\n          linha: startLine,\r\n          mensagem: `Função aninhada em nível ${_aninhamento} (máx: ${LIMITE_ANINHAMENTO})`,\r\n          origem: 'analista-funcoes-longas',\r\n        });\r\n      }\r\n\r\n      // Verifica se a função não tem comentário imediatamente acima\r\n      if (fn.leadingComments == null || fn.leadingComments.length === 0) {\r\n        ocorrencias.push({\r\n          tipo: 'FUNCAO_SEM_COMENTARIO',\r\n          severidade: 1,\r\n          nivel: 'info',\r\n          relPath,\r\n          arquivo: relPath,\r\n          linha: startLine,\r\n          mensagem: `Função sem comentário acima.`,\r\n          origem: 'analista-funcoes-longas',\r\n        });\r\n      }\r\n    }\r\n\r\n    function analisarRecursivo(path: import('@babel/traverse').NodePath, aninhamento: number = 0) {\r\n      const node = 'node' in path ? path.node : path;\r\n      const type = (node as { type?: string }).type;\r\n      if (\r\n        type === 'FunctionDeclaration' ||\r\n        type === 'FunctionExpression' ||\r\n        type === 'ArrowFunctionExpression'\r\n      ) {\r\n        analisar(\r\n          node as FunctionDeclaration | FunctionExpression | ArrowFunctionExpression,\r\n          aninhamento,\r\n        );\r\n        aninhamento++;\r\n      }\r\n      if (typeof (path as { traverse?: unknown }).traverse === 'function') {\r\n        (path as { traverse: (visitors: Record<string, (p: NodePath) => void>) => void }).traverse({\r\n          FunctionDeclaration(p: NodePath) {\r\n            analisarRecursivo(p, aninhamento + 1);\r\n          },\r\n          FunctionExpression(p: NodePath) {\r\n            analisarRecursivo(p, aninhamento + 1);\r\n          },\r\n          ArrowFunctionExpression(p: NodePath) {\r\n            analisarRecursivo(p, aninhamento + 1);\r\n          },\r\n        });\r\n      }\r\n    }\r\n\r\n    // --- Fluxo centralizado e robusto ---\r\n    // 1. NodePath real: use traverse e recursão\r\n    if (ast && typeof ast.traverse === 'function') {\r\n      analisarRecursivo(ast, 0);\r\n      return ocorrencias;\r\n    }\r\n\r\n    // 2. AST puro ou mock: só processa body do File, nunca recursiona\r\n    const fileNode =\r\n      ast &&\r\n      typeof ast === 'object' &&\r\n      'node' in ast &&\r\n      (ast as { node: unknown }).node &&\r\n      (ast as { node: { type?: string; body?: unknown[] } }).node.type === 'File' &&\r\n      Array.isArray((ast as { node: { body?: unknown[] } }).node.body)\r\n        ? ((ast as { node: unknown }).node as unknown as { body: unknown[] })\r\n        : ast &&\r\n            typeof ast === 'object' &&\r\n            (ast as { type?: string }).type === 'File' &&\r\n            Array.isArray((ast as { body?: unknown[] }).body)\r\n          ? (ast as unknown as { body: unknown[] })\r\n          : null;\r\n\r\n    if (fileNode) {\r\n      const body = fileNode.body as unknown[];\r\n      for (const child of body) {\r\n        if (\r\n          typeof child === 'object' &&\r\n          child !== null &&\r\n          ((child as { type?: string }).type === 'FunctionDeclaration' ||\r\n            (child as { type?: string }).type === 'FunctionExpression' ||\r\n            (child as { type?: string }).type === 'ArrowFunctionExpression')\r\n        ) {\r\n          analisar(child as FunctionDeclaration | FunctionExpression | ArrowFunctionExpression, 0);\r\n        }\r\n      }\r\n      return ocorrencias;\r\n    }\r\n\r\n    // Se não for nenhum dos casos acima, retorna vazio\r\n    return ocorrencias;\r\n  },\r\n  nome: 'analista-funcoes-longas',\r\n  categoria: 'complexidade',\r\n  descricao:\r\n    'Detecta funcoes muito longas, com muitos parametros, aninhamento excessivo ou sem comentario',\r\n  limites: {\r\n    linhas: LIMITE_LINHAS,\r\n    params: LIMITE_PARAMETROS,\r\n    aninhamento: LIMITE_ANINHAMENTO,\r\n  },\r\n  test: (relPath: string): boolean => relPath.endsWith('.js') || relPath.endsWith('.ts'),\r\n  global: false,\r\n});\r\n"]}