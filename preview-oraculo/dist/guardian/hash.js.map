{"version":3,"file":"hash.js","sourceRoot":"","sources":["../../src/guardian/hash.ts"],"names":[],"mappings":"AAAA,+BAA+B;AAC/B,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACpD,OAAO,EAAE,cAAc,EAAE,MAAM,iBAAiB,CAAC;AAQjD;;GAEG;AACH,MAAM,UAAU,YAAY,CAAC,QAAgB;IAC3C,MAAM,UAAU,GAAG,CAAC,cAAc,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;IAC7D,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,SAAS,EAAE,CAAC,CAAC;IACzC,KAAK,MAAM,GAAG,IAAI,UAAU,EAAE,CAAC;QAC7B,IAAI,CAAC;YACH,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC;gBAAE,SAAS,CAAC,mCAAmC;YACxE,OAAO,UAAU,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACxD,CAAC;QAAC,MAAM,CAAC;YACP,gBAAgB;QAClB,CAAC;IACH,CAAC;IACD,uEAAuE;IACvE,IAAI,IAAI,GAAG,CAAC,CAAC;IACb,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACzC,IAAI,GAAG,CAAC,IAAI,GAAG,EAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IACpD,CAAC;IACD,OAAO,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AAC5C,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,uBAAuB,CAAC,QAAgB;IACtD,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IACpC,MAAM,QAAQ,GAAsB;QAClC,IAAI,EAAE,YAAY,CAAC,QAAQ,CAAC;QAC5B,MAAM,EAAE,MAAM,CAAC,MAAM;QACrB,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,EAAE;KACxC,CAAC;IACF,OAAO,QAAQ,CAAC,IAAI,CAAC;AACvB,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT\r\nimport { createHash, getHashes } from 'node:crypto';\r\nimport { ALGORITMO_HASH } from './constantes.js';\r\n\r\nexport interface SnapshotDetalhado {\r\n  hash: string;\r\n  linhas: number;\r\n  amostra: string;\r\n}\r\n\r\n/**\r\n * Gera um hash hexadecimal a partir do conteúdo fornecido.\r\n */\r\nexport function gerarHashHex(conteudo: string): string {\r\n  const candidatos = [ALGORITMO_HASH, 'sha256', 'sha1', 'md5'];\r\n  const disponiveis = new Set(getHashes());\r\n  for (const alg of candidatos) {\r\n    try {\r\n      if (!disponiveis.has(alg)) continue; // ignora não suportados no runtime\r\n      return createHash(alg).update(conteudo).digest('hex');\r\n    } catch {\r\n      // tenta próximo\r\n    }\r\n  }\r\n  // Fallback ultra simples (não criptográfico) — evita exception ruidosa\r\n  let hash = 0;\r\n  for (let i = 0; i < conteudo.length; i++) {\r\n    hash = (hash * 31 + conteudo.charCodeAt(i)) >>> 0;\r\n  }\r\n  return hash.toString(16).padStart(8, '0');\r\n}\r\n\r\n/**\r\n * Gera um snapshot do conteúdo incluindo:\r\n * - Hash de integridade\r\n * - Número de linhas\r\n * - Amostra textual do início do arquivo\r\n */\r\nexport function gerarSnapshotDoConteudo(conteudo: string): string {\r\n  const linhas = conteudo.split('\\n');\r\n  const snapshot: SnapshotDetalhado = {\r\n    hash: gerarHashHex(conteudo),\r\n    linhas: linhas.length,\r\n    amostra: linhas[0]?.slice(0, 200) ?? '',\r\n  };\r\n  return snapshot.hash;\r\n}\r\n"]}