{"version":3,"file":"registros.js","sourceRoot":"","sources":["../../src/guardian/registros.ts"],"names":[],"mappings":"AAAA,+BAA+B;AAC/B,OAAO,EAAE,YAAY,EAAE,SAAS,EAAE,MAAM,iCAAiC,CAAC;AAC1E,OAAO,IAAI,MAAM,WAAW,CAAC;AAC7B,OAAO,EAAE,GAAG,EAAE,MAAM,4BAA4B,CAAC;AACjD,OAAO,EAAE,MAAM,EAAE,MAAM,+BAA+B,CAAC;AACvD,OAAO,EAAE,uBAAuB,EAAE,MAAM,WAAW,CAAC;AAGpD,MAAM,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,kBAAkB,CAAC,CAAC;AAOvE;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,eAAe,CACnC,WAAwB,EACxB,UAAkB,cAAc;IAEhC,MAAM,SAAS,GAA0B,EAAE,CAAC;IAE5C,KAAK,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,WAAW,EAAE,CAAC;QAC/C,IAAI,CAAC,OAAO,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE;YAAE,SAAS;QACzE,MAAM,IAAI,GAAG,uBAAuB,CAAC,OAAO,CAAC,CAAC;QAC9C,SAAS,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC;IAC7C,CAAC;IAED,MAAM,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,EAAE,EAAE,CAClC,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAC9D,CAAC;IACF,MAAM,YAAY,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;IACvC,GAAG,CAAC,OAAO,CAAC,yCAAyC,OAAO,EAAE,CAAC,CAAC;AAClE,CAAC;AAED;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,iBAAiB,CACrC,UAAkB,cAAc;IAEhC,IAAI,CAAC;QACH,OAAO,MAAM,SAAS,CAAwB,OAAO,CAAC,CAAC;IACzD,CAAC;IAAC,MAAM,CAAC;QACP,GAAG,CAAC,KAAK,CAAC,oCAAoC,OAAO,EAAE,CAAC,CAAC;QACzD,OAAO,EAAE,CAAC;IACZ,CAAC;AACH,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT\r\nimport { salvarEstado, lerEstado } from '@zeladores/util/persistencia.js';\r\nimport path from 'node:path';\r\nimport { log } from '@nucleo/constelacao/log.js';\r\nimport { config } from '@nucleo/constelacao/cosmos.js';\r\nimport { gerarSnapshotDoConteudo } from './hash.js';\r\nimport { FileEntry } from '@tipos/tipos.js';\r\n\r\nconst DESTINO_PADRAO = path.join(config.STATE_DIR, 'integridade.json');\r\n\r\nexport interface RegistroIntegridade {\r\n  arquivo: string;\r\n  hash: string;\r\n}\r\n\r\n/**\r\n * Salva os hashes dos arquivos fornecidos em um arquivo de integridade.\r\n */\r\nexport async function salvarRegistros(\r\n  fileEntries: FileEntry[],\r\n  destino: string = DESTINO_PADRAO,\r\n): Promise<void> {\r\n  const registros: RegistroIntegridade[] = [];\r\n\r\n  for (const { relPath, content } of fileEntries) {\r\n    if (!relPath || typeof content !== 'string' || !content.trim()) continue;\r\n    const hash = gerarSnapshotDoConteudo(content);\r\n    registros.push({ arquivo: relPath, hash });\r\n  }\r\n\r\n  await import('node:fs').then((fs) =>\r\n    fs.promises.mkdir(path.dirname(destino), { recursive: true }),\r\n  );\r\n  await salvarEstado(destino, registros);\r\n  log.sucesso(`üõ°Ô∏è Registro de integridade salvo em: ${destino}`);\r\n}\r\n\r\n/**\r\n * Carrega os registros de integridade persistidos. Retorna lista vazia se n√£o existir.\r\n */\r\nexport async function carregarRegistros(\r\n  caminho: string = DESTINO_PADRAO,\r\n): Promise<RegistroIntegridade[]> {\r\n  try {\r\n    return await lerEstado<RegistroIntegridade[]>(caminho);\r\n  } catch {\r\n    log.aviso(`‚ö†Ô∏è Nenhum registro encontrado em ${caminho}`);\r\n    return [];\r\n  }\r\n}\r\n"]}