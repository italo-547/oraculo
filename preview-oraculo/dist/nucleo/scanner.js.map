{"version":3,"file":"scanner.js","sourceRoot":"","sources":["../../src/nucleo/scanner.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\r\nimport micromatch from 'micromatch';\r\nimport { lerEstado, lerArquivoTexto } from '@zeladores/util/persistencia.js';\r\nimport { promises as fs } from 'node:fs';\r\nimport type { Dirent, Stats } from 'node:fs';\r\nimport path from 'path';\r\nimport { config } from '@nucleo/constelacao/cosmos.js';\r\nimport { shouldInclude } from '@nucleo/constelacao/include-exclude.js';\r\nimport type { FileMap, FileEntry } from '@tipos/tipos.js';\r\n\r\ninterface ScanOptions {\r\n  includeContent?: boolean;\r\n  filter?: (relPath: string, entry: Dirent) => boolean;\r\n  onProgress?: (msg: string) => void;\r\n}\r\n\r\nexport async function scanRepository(baseDir: string, options: ScanOptions = {}): Promise<FileMap> {\r\n  // Helpers locais de normalização (não exportados)\r\n  const toPosix = (s: string) => s.replace(/\\\\+/g, '/');\r\n  const trimDotSlash = (s: string) => s.replace(/^\\.\\/?/, '');\r\n\r\n  const {\r\n    includeContent = true,\r\n    filter = () => true,\r\n    onProgress = () => {\r\n      return undefined;\r\n    },\r\n  } = options;\r\n  // Em modo scan-only, não devemos ler conteúdos de arquivos\r\n  const efetivoIncluirConteudo = includeContent && !config.SCAN_ONLY;\r\n\r\n  const fileMap: FileMap = {};\r\n  const statCache = new Map<string, Stats>();\r\n  // Avalia configuração por varredura\r\n  const gruposRaw =\r\n    (config as unknown as { CLI_INCLUDE_GROUPS?: string[][] }).CLI_INCLUDE_GROUPS || [];\r\n  const includeGroups = Array.isArray(gruposRaw) ? gruposRaw : [];\r\n  const includeGroupsNorm: string[][] = includeGroups.map((g) =>\r\n    (g || []).map((p) => toPosix(trimDotSlash(String(p || '')))),\r\n  );\r\n  const includePatterns = Array.isArray(config.CLI_INCLUDE_PATTERNS)\r\n    ? (config.CLI_INCLUDE_PATTERNS as string[])\r\n    : [];\r\n  const includePatternsNorm = includePatterns.map((p) => toPosix(trimDotSlash(String(p || ''))));\r\n  const excludePatternsNorm = (\r\n    Array.isArray(config.CLI_EXCLUDE_PATTERNS) ? (config.CLI_EXCLUDE_PATTERNS as string[]) : []\r\n  ).map((p) => toPosix(String(p || '')));\r\n  const dynIgnores =\r\n    (config.INCLUDE_EXCLUDE_RULES && config.INCLUDE_EXCLUDE_RULES.globalExcludeGlob) ||\r\n    (Array.isArray(config.ZELADOR_IGNORE_PATTERNS)\r\n      ? (config.ZELADOR_IGNORE_PATTERNS as string[])\r\n      : []);\r\n  const ignorePatternsNorm = (dynIgnores as string[]).map((p) => toPosix(String(p || '')));\r\n\r\n  const hasInclude = includeGroupsNorm.length > 0 || includePatternsNorm.length > 0;\r\n  // Sinaliza quando os includes pedem ocorrências em qualquer profundidade (ex.: '**/nome/**') ou quando\r\n  // o usuário forneceu nomes simples (que o expandIncludes converte em '**/nome/**').\r\n  const pedeOcorrenciasGlobais = hasInclude\r\n    ? [...includePatternsNorm, ...includeGroupsNorm.flat()].some((p) => p.startsWith('**/'))\r\n    : false;\r\n  // node_modules explicitamente incluído em algum pattern ou grupo de include\r\n  const includeNodeModulesExplicit = hasInclude\r\n    ? [...includePatternsNorm, ...includeGroupsNorm.flat()].some((p) =>\r\n        /(^|\\/)node_modules(\\/|$)/.test(String(p || '')),\r\n      )\r\n    : false;\r\n\r\n  // Quando includes estão ativos, derivamos diretórios-raiz a partir dos prefixos antes do primeiro metacaractere\r\n  function calcularIncludeRoots(padroes: string[] | undefined, grupos?: string[][]): string[] {\r\n    const roots = new Set<string>();\r\n    const candidatos = new Set<string>();\r\n    if (Array.isArray(padroes)) padroes.forEach((p) => candidatos.add(toPosix(trimDotSlash(p))));\r\n    if (Array.isArray(grupos))\r\n      for (const g of grupos) g.forEach((p) => candidatos.add(toPosix(trimDotSlash(p))));\r\n    if (candidatos.size === 0) return [];\r\n    const META = /[\\\\*\\?\\{\\}\\[\\]]/; // caracteres meta de glob\r\n    for (const raw of candidatos) {\r\n      let p = String(raw).trim();\r\n      if (!p) continue;\r\n      p = toPosix(trimDotSlash(p));\r\n      let anchor = '';\r\n      if (p.includes('/**')) anchor = p.slice(0, p.indexOf('/**'));\r\n      else if (p.includes('/*')) anchor = p.slice(0, p.indexOf('/*'));\r\n      else if (p.includes('/')) anchor = p.split('/')[0];\r\n      else anchor = '';\r\n      anchor = anchor.replace(/\\/+/g, '/').replace(/\\/$/, '');\r\n      // Ignora anchors inválidos: vazios, apenas '.', '**' ou contendo metacaracteres (ex.: '**/src')\r\n      if (anchor && anchor !== '.' && anchor !== '**' && !META.test(anchor)) {\r\n        const baseNorm = toPosix(String(baseDir)).replace(/\\/$/, '');\r\n        const rootPosix = `${baseNorm}/${anchor}`.replace(/\\/+/g, '/');\r\n        roots.add(rootPosix);\r\n      }\r\n    }\r\n    return Array.from(roots);\r\n  }\r\n\r\n  // Matcher de include considerando grupos: AND dentro do grupo, OR entre grupos\r\n  function matchInclude(relPath: string): boolean {\r\n    // Função auxiliar: avalia se um padrão casa com o caminho relativo\r\n    const matchesPattern = (rp: string, p: string): boolean => {\r\n      if (!p) return false;\r\n      // Casamento direto via micromatch\r\n      if (micromatch.isMatch(rp, [p])) return true;\r\n      // Compat extra: reconhece padrões simples com sufixo '/**' por prefixo\r\n      if (p.endsWith('/**')) {\r\n        const base = p.slice(0, -3); // remove '/**'\r\n        if (base && rp.startsWith(base)) return true;\r\n      }\r\n      // Quando o padrão não possui metacaracteres, trate como diretório/segmento\r\n      const META = /[\\\\*\\?\\{\\}\\[\\]]/;\r\n      if (!META.test(p)) {\r\n        const pat = p.replace(/\\/+$|\\/+$|^\\.\\/?/g, '').replace(/\\/+/g, '/');\r\n        if (!pat) return false;\r\n        // Se contém barra: trate como caminho base (prefixo)\r\n        if (pat.includes('/')) {\r\n          if (rp === pat) return true;\r\n          if (rp.startsWith(pat + '/')) return true;\r\n          if (rp.includes('/' + pat + '/')) return true;\r\n          if (rp.endsWith('/' + pat)) return true;\r\n          return false;\r\n        }\r\n        // Segmento simples: casa em qualquer nível\r\n        if (rp === pat) return true;\r\n        if (rp.startsWith(pat + '/')) return true;\r\n        if (rp.includes('/' + pat + '/')) return true;\r\n        if (rp.endsWith('/' + pat)) return true;\r\n        return false;\r\n      }\r\n      return false;\r\n    };\r\n    // Função auxiliar: extrai a \"base\" do padrão (token original antes das ampliações)\r\n    const baseFromPattern = (p: string): string => {\r\n      let b = p.trim();\r\n      b = b.replace(/^\\*\\*\\//, ''); // remove '**/' inicial\r\n      b = b.replace(/\\/\\*\\*$/, ''); // remove '/**' final\r\n      b = b.replace(/^\\.\\/?/, ''); // remove './' inicial\r\n      b = b.replace(/\\/+/g, '/').replace(/\\/$/, '');\r\n      return b;\r\n    };\r\n    // Quando houver grupos, aplica estritamente: OR entre grupos com AND dentro do grupo\r\n    if (includeGroupsNorm.length > 0) {\r\n      for (const g of includeGroupsNorm) {\r\n        // Agrupa padrões por base (permite OR entre variantes de um mesmo token e AND entre tokens)\r\n        const porBase = new Map<string, string[]>();\r\n        for (const p of g) {\r\n          const base = baseFromPattern(p);\r\n          const arr = porBase.get(base) || [];\r\n          arr.push(p);\r\n          porBase.set(base, arr);\r\n        }\r\n        const allBasesMatch = Array.from(porBase.values()).every((lista) =>\r\n          lista.some((p) => matchesPattern(relPath, p)),\r\n        );\r\n        if (allBasesMatch) return true;\r\n      }\r\n      // Sem correspondência em nenhum grupo -> não inclui\r\n      return false;\r\n    }\r\n    // Sem grupos: lista achatada (OR)\r\n    if (includePatternsNorm.length && micromatch.isMatch(relPath, includePatternsNorm)) return true;\r\n    // Compat extra também para padrões simples quando não há grupos\r\n    for (const p of includePatternsNorm || []) if (matchesPattern(relPath, p)) return true;\r\n    return false;\r\n  }\r\n\r\n  async function scan(dir: string): Promise<void> {\r\n    let entries: Dirent[];\r\n    try {\r\n      entries = await fs.readdir(dir, { withFileTypes: true });\r\n      entries.sort((a, b) => a.name.localeCompare(b.name));\r\n    } catch (err) {\r\n      onProgress(\r\n        JSON.stringify({\r\n          tipo: 'erro',\r\n          acao: 'acessar',\r\n          caminho: dir,\r\n          mensagem:\r\n            typeof err === 'object' && err && 'message' in err\r\n              ? (err as { message: string }).message\r\n              : String(err),\r\n        }),\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Logar apenas diretórios sendo examinados\r\n    onProgress(JSON.stringify({ tipo: 'diretorio', acao: 'examinar', caminho: dir }));\r\n\r\n    for (const entry of entries) {\r\n      const fullPath = path.join(dir, entry.name);\r\n      const relPathRaw = path.relative(baseDir, fullPath);\r\n      // Normaliza para separador POSIX para que micromatch funcione de forma consistente no Windows\r\n      const relPath = toPosix(relPathRaw);\r\n      // ------------------------------\r\n      // Filtros de inclusão/exclusão aplicados corretamente: diretórios x arquivos\r\n      if (entry.isDirectory() && !entry.isSymbolicLink()) {\r\n        // Diretórios: aplica excludes e ignores padrão (ignores somente quando não há include),\r\n        // além de guarda específica para node_modules.\r\n        if (micromatch.isMatch(relPath, excludePatternsNorm)) {\r\n          continue; // diretório excluído explicitamente\r\n        }\r\n        if (!hasInclude && micromatch.isMatch(relPath, ignorePatternsNorm)) {\r\n          continue; // ignora diretórios padrão quando não há include\r\n        }\r\n        if (/(^|\\/)node_modules(\\/|$)/.test(relPath) && !includeNodeModulesExplicit) {\r\n          continue; // proteção: não descer em node_modules salvo inclusão explícita\r\n        }\r\n        await scan(fullPath);\r\n      } else {\r\n        // Arquivos: aplica include (quando presente), excludes/ignores e filtro customizado\r\n        if (hasInclude && !matchInclude(relPath)) {\r\n          continue; // arquivo não incluso explicitamente\r\n        }\r\n        if (micromatch.isMatch(relPath, excludePatternsNorm)) {\r\n          continue; // arquivo excluído\r\n        }\r\n        if (!hasInclude && micromatch.isMatch(relPath, ignorePatternsNorm)) {\r\n          continue; // ignore padrão quando não há include\r\n        }\r\n        // Filtro customizado e regras dinâmicas opcionais\r\n        // Regras dinâmicas: quando há includes explícitos, estes sobrepõem ignores globais\r\n        const regrasPermitem =\r\n          !config.INCLUDE_EXCLUDE_RULES ||\r\n          hasInclude ||\r\n          shouldInclude(relPath, entry, config.INCLUDE_EXCLUDE_RULES);\r\n        if (!regrasPermitem || !filter(relPath, entry)) {\r\n          continue; // filtro customizado\r\n        }\r\n        try {\r\n          // Tenta obter stat; se rejeitar, registra erro e não inclui arquivo\r\n          let stat: unknown = statCache.get(fullPath);\r\n          if (!stat) {\r\n            try {\r\n              stat = await fs.stat(fullPath);\r\n              statCache.set(fullPath, stat as Stats);\r\n            } catch (e) {\r\n              onProgress(\r\n                JSON.stringify({\r\n                  tipo: 'erro',\r\n                  acao: 'ler',\r\n                  caminho: relPath,\r\n                  mensagem:\r\n                    typeof e === 'object' && e && 'message' in e\r\n                      ? (e as { message: string }).message\r\n                      : String(e),\r\n                }),\r\n              );\r\n              continue;\r\n            }\r\n          }\r\n          if (stat == null) {\r\n            throw new Error('Stat indefinido para ' + fullPath);\r\n          }\r\n          let mtimeMs = 0;\r\n          if (typeof stat === 'object' && stat && 'mtimeMs' in (stat as Stats)) {\r\n            const mm = (stat as Stats).mtimeMs;\r\n            if (typeof mm === 'number') mtimeMs = mm;\r\n          }\r\n\r\n          let content: string | null = null;\r\n          if (efetivoIncluirConteudo) {\r\n            const emTeste = !!process.env.VITEST;\r\n            try {\r\n              if (emTeste) {\r\n                // Mantém compat com testes que mockam lerEstado\r\n                content = await lerEstado<string>(fullPath);\r\n              } else {\r\n                content = await lerArquivoTexto(fullPath);\r\n              }\r\n            } catch (e) {\r\n              // Em caso de erro de leitura, registra via onProgress e segue\r\n              onProgress(\r\n                JSON.stringify({\r\n                  tipo: 'erro',\r\n                  acao: 'ler',\r\n                  caminho: relPath,\r\n                  mensagem:\r\n                    typeof e === 'object' && e && 'message' in e\r\n                      ? (e as { message: string }).message\r\n                      : String(e),\r\n                }),\r\n              );\r\n              content = null;\r\n            }\r\n          }\r\n\r\n          const entryObj: FileEntry = {\r\n            fullPath,\r\n            relPath,\r\n            content,\r\n            ultimaModificacao: mtimeMs,\r\n          };\r\n\r\n          fileMap[relPath] = entryObj;\r\n          // Logar cada arquivo individualmente para compatibilidade com testes\r\n          // Evita ruído quando relatórios silenciosos estão ativos (modo --json)\r\n          if (!config.REPORT_SILENCE_LOGS) {\r\n            onProgress(`✅ Arquivo lido: ${relPath}`);\r\n          }\r\n        } catch (err) {\r\n          onProgress(\r\n            JSON.stringify({\r\n              tipo: 'erro',\r\n              acao: 'ler',\r\n              caminho: relPath,\r\n              mensagem:\r\n                typeof err === 'object' && err && 'message' in err\r\n                  ? (err as { message: string }).message\r\n                  : String(err),\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Pontos de partida da varredura\r\n  let startDirs = hasInclude\r\n    ? calcularIncludeRoots(\r\n        config.CLI_INCLUDE_PATTERNS as string[] | undefined,\r\n        (config as unknown as { CLI_INCLUDE_GROUPS?: string[][] }).CLI_INCLUDE_GROUPS,\r\n      )\r\n    : [];\r\n  // Quando o include pede ocorrências em qualquer profundidade, adicionamos também a base do repo para\r\n  // garantir que diretórios-alvo apareçam em níveis arbitrários (ex.: packages/*/node_modules).\r\n  if (hasInclude && pedeOcorrenciasGlobais) {\r\n    const baseNorm = toPosix(String(baseDir)).replace(/\\/$/, '');\r\n    if (!startDirs.includes(baseNorm)) startDirs = [baseNorm, ...startDirs];\r\n  }\r\n  // Se nenhum root foi derivado (ex.: includes somente de arquivos como 'a.txt'), varremos a base inteira\r\n  // para permitir que o filtro de includes atue nos arquivos diretamente.\r\n  if (hasInclude && startDirs.length === 0) {\r\n    // Sem roots deriváveis (ex.: include apenas 'a.txt'): varre só a raiz para permitir filtro\r\n    await scan(baseDir);\r\n    return fileMap;\r\n  }\r\n  if (startDirs.length === 0) {\r\n    await scan(baseDir);\r\n  } else {\r\n    const vistos = new Set<string>();\r\n    for (const d of startDirs) {\r\n      // Evita normalização com path.resolve para não quebrar mocks de testes (mantém separador POSIX)\r\n      let norm = d;\r\n      // Remove barra final para compat com mocks que comparam por igualdade\r\n      if (/[\\\\\\/]$/.test(norm)) norm = norm.replace(/[\\\\\\/]+$/, '');\r\n      if (vistos.has(norm)) continue;\r\n      vistos.add(norm);\r\n      // Tenta primeiro tratar como diretório sem depender de stat (mocks podem retornar funções)\r\n      try {\r\n        await fs.readdir(norm);\r\n        await scan(norm);\r\n        continue;\r\n      } catch {\r\n        // não é diretório (ou inacessível); tenta fluxo de arquivo abaixo\r\n      }\r\n      // Quando o root derivado for um arquivo, processe-o diretamente\r\n      try {\r\n        let st = statCache.get(norm);\r\n        if (!st) {\r\n          st = await fs.stat(norm);\r\n          statCache.set(norm, st);\r\n        }\r\n        let isDir = false;\r\n        if (\r\n          st &&\r\n          typeof (st as unknown as { isDirectory: () => boolean }).isDirectory === 'function'\r\n        ) {\r\n          isDir = st.isDirectory();\r\n        } else {\r\n          // Fallback quando stat mockado não possui isDirectory confiável: tenta readdir\r\n          try {\r\n            await fs.readdir(norm);\r\n            isDir = true;\r\n          } catch {\r\n            isDir = false;\r\n          }\r\n        }\r\n        if (isDir) {\r\n          await scan(norm);\r\n        } else {\r\n          // Alguns testes mockam stat.isDirectory() como false mesmo para diretórios;\r\n          // se conseguirmos listar, tratamos como diretório.\r\n          try {\r\n            await fs.readdir(norm);\r\n            await scan(norm);\r\n            continue;\r\n          } catch {\r\n            // segue como arquivo\r\n          }\r\n          const relPathRaw = path.relative(baseDir, norm);\r\n          const relPath = toPosix(relPathRaw);\r\n          // Aplica as mesmas regras de filtragem de arquivos\r\n          if (hasInclude && !matchInclude(relPath)) {\r\n            continue;\r\n          }\r\n          if (micromatch.isMatch(relPath, excludePatternsNorm)) {\r\n            continue;\r\n          }\r\n          if (!hasInclude && micromatch.isMatch(relPath, ignorePatternsNorm)) {\r\n            continue;\r\n          }\r\n          // Filtro customizado exige Dirent; criamos um stub mínimo\r\n          const fakeDirent: Dirent = {\r\n            name: path.basename(norm),\r\n            isDirectory: () => false,\r\n            isSymbolicLink: () => false,\r\n          } as unknown as Dirent;\r\n          const regrasPermitem =\r\n            !config.INCLUDE_EXCLUDE_RULES ||\r\n            hasInclude ||\r\n            shouldInclude(relPath, fakeDirent, config.INCLUDE_EXCLUDE_RULES);\r\n          if (!regrasPermitem || !filter(relPath, fakeDirent)) continue;\r\n\r\n          let content: string | null = null;\r\n          if (efetivoIncluirConteudo) {\r\n            const emTeste = !!process.env.VITEST;\r\n            try {\r\n              if (emTeste) content = await lerEstado<string>(norm);\r\n              else content = await lerArquivoTexto(norm);\r\n            } catch (e) {\r\n              onProgress(\r\n                JSON.stringify({\r\n                  tipo: 'erro',\r\n                  acao: 'ler',\r\n                  caminho: relPath,\r\n                  mensagem:\r\n                    typeof e === 'object' && e && 'message' in e\r\n                      ? (e as { message: string }).message\r\n                      : String(e),\r\n                }),\r\n              );\r\n              content = null;\r\n            }\r\n          }\r\n\r\n          fileMap[relPath] = {\r\n            fullPath: norm,\r\n            relPath,\r\n            content,\r\n            ultimaModificacao:\r\n              (st && 'mtimeMs' in st ? (st as Stats).mtimeMs : Date.now()) || Date.now(),\r\n          };\r\n          if (!config.REPORT_SILENCE_LOGS) {\r\n            onProgress(`✅ Arquivo lido: ${relPath}`);\r\n          }\r\n        }\r\n      } catch (e) {\r\n        onProgress(\r\n          JSON.stringify({\r\n            tipo: 'erro',\r\n            acao: 'acessar',\r\n            caminho: norm,\r\n            mensagem:\r\n              typeof e === 'object' && e && 'message' in e\r\n                ? (e as { message: string }).message\r\n                : String(e),\r\n          }),\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return fileMap;\r\n}\r\n"]}