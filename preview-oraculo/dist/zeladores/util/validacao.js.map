{"version":3,"file":"validacao.js","sourceRoot":"","sources":["../../../src/zeladores/util/validacao.ts"],"names":[],"mappings":"AAAA,+BAA+B;AAC/B,OAAO,IAAI,MAAM,WAAW,CAAC;AAE7B,kGAAkG;AAClG,MAAM,UAAU,mBAAmB,CAAC,CAAS;IAC3C,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC;IAC3B,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACxD,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;IACjC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;QAAE,OAAO,IAAI,CAAC,CAAC,gBAAgB;IACzD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,UAAU,qBAAqB,CAAC,CAAU,EAAE,IAAY;IAC5D,IAAI,CAAC,KAAK,SAAS,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,EAAE;QAAE,OAAO,IAAI,CAAC;IAC3D,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACpB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;QAAE,MAAM,IAAI,KAAK,CAAC,uBAAuB,IAAI,KAAK,CAAC,EAAE,CAAC,CAAC;IACvF,OAAO,CAAC,CAAC;AACX,CAAC;AAOD,oFAAoF;AACpF,MAAM,UAAU,kBAAkB,CAAC,KAA8B;IAC/D,MAAM,KAAK,GAA8B,EAAE,CAAC;IAC5C,IAAI,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,WAAW,EAAE,CAAC;QACxC,KAAK,CAAC,IAAI,CAAC;YACT,MAAM,EAAE,kBAAkB;YAC1B,QAAQ,EAAE,qEAAqE;SAChF,CAAC,CAAC;IACL,CAAC;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED,MAAM,UAAU,cAAc,CAAC,KAA8B;IAC3D,MAAM,KAAK,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;IACxC,IAAI,KAAK,CAAC,MAAM,EAAE,CAAC;QACjB,MAAM,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1E,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;IAC3B,CAAC;AACH,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT\r\nimport path from 'node:path';\r\n\r\n/** Normaliza um caminho assegurando que permanece dentro da CWD (remove tentativas de escape). */\r\nexport function normalizarPathLocal(p: string): string {\r\n  const base = process.cwd();\r\n  const abs = path.isAbsolute(p) ? p : path.join(base, p);\r\n  const norm = path.normalize(abs);\r\n  if (!norm.startsWith(base)) return base; // impede escape\r\n  return norm;\r\n}\r\n\r\nexport function validarNumeroPositivo(v: unknown, nome: string): number | null {\r\n  if (v === undefined || v === null || v === '') return null;\r\n  const n = Number(v);\r\n  if (!Number.isFinite(n) || n < 0) throw new Error(`Valor inválido para ${nome}: ${v}`);\r\n  return n;\r\n}\r\n\r\nexport interface ErroValidacaoCombinacao {\r\n  codigo: string;\r\n  mensagem: string;\r\n}\r\n\r\n/** Regras simples de combinação de flags globais. Expandir conforme novos casos. */\r\nexport function validarCombinacoes(flags: Record<string, unknown>): ErroValidacaoCombinacao[] {\r\n  const erros: ErroValidacaoCombinacao[] = [];\r\n  if (flags.scanOnly && flags.incremental) {\r\n    erros.push({\r\n      codigo: 'SCAN_INCREMENTAL',\r\n      mensagem: 'Não combinar --scan-only com --incremental (incremental exige AST).',\r\n    });\r\n  }\r\n  return erros;\r\n}\r\n\r\nexport function sanitizarFlags(flags: Record<string, unknown>): void {\r\n  const erros = validarCombinacoes(flags);\r\n  if (erros.length) {\r\n    const detalhe = erros.map((e) => `${e.codigo}: ${e.mensagem}`).join('; ');\r\n    throw new Error(detalhe);\r\n  }\r\n}\r\n"]}